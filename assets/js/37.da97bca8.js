(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{648:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",[t._v("HTTP的介绍")])]),t._v(" "),s("h2",{attrs:{id:"http-是建立在-tcp-还是-udp-之上的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-是建立在-tcp-还是-udp-之上的？"}},[t._v("#")]),t._v(" HTTP 是建立在 TCP 还是 UDP 之上的？")]),t._v(" "),s("blockquote",[s("p",[t._v("TCP")])]),t._v(" "),s("h2",{attrs:{id:"一次完整的-http-通信是什么样子？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一次完整的-http-通信是什么样子？"}},[t._v("#")]),t._v(" 一次完整的 HTTP 通信是什么样子？")]),t._v(" "),s("h5",{attrs:{id:"_1-建立tcp连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-建立tcp连接"}},[t._v("#")]),t._v(" 1. 建立TCP连接")]),t._v(" "),s("blockquote",[s("p",[t._v("在HTTP⼯作开始之前，客户端⾸先要通过网络与服务器建立连接，该连接是通过TCP 来完成的。HTTP 是比 TCP 更⾼层次的应用层协议，根据规则，只有低层协议建⽴之后，才能进行⾼层协议的连接，因此，⾸先要建立 TCP 连接，⼀般 TCP 连接的端⼝号是80；")])]),t._v(" "),s("h5",{attrs:{id:"_2-客户端向服务器发送请求命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-客户端向服务器发送请求命令"}},[t._v("#")]),t._v(" 2. 客户端向服务器发送请求命令")]),t._v(" "),s("blockquote",[s("p",[t._v("⼀旦建立了TCP连接，客户端就会向服务器发送请求命令；\n例如：GET/info HTTP/1.1")])]),t._v(" "),s("h5",{attrs:{id:"_3-客户端发送请求头信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-客户端发送请求头信息"}},[t._v("#")]),t._v(" 3. 客户端发送请求头信息")]),t._v(" "),s("blockquote",[s("p",[t._v("客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了⼀空白行来通知服务器，它已经结束了该头信息的发送；")])]),t._v(" "),s("h5",{attrs:{id:"_4-服务器应答"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务器应答"}},[t._v("#")]),t._v(" 4. 服务器应答")]),t._v(" "),s("blockquote",[s("p",[t._v("客户端向服务器发出请求后，服务器会客户端返回响应；\n例如： HTTP/1.1 200 OK\n响应的第⼀部分是协议的版本号和响应状态码")])]),t._v(" "),s("h5",{attrs:{id:"_5-服务器返回响应头信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-服务器返回响应头信息"}},[t._v("#")]),t._v(" 5. 服务器返回响应头信息")]),t._v(" "),s("blockquote",[s("p",[t._v("正如客户端会随同请求发送关于⾃身的信息一样，服务器也会随同响应向⽤户发送关于它⾃己的数据及被请求的文档")])]),t._v(" "),s("h5",{attrs:{id:"_6-服务器向客户端发送数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-服务器向客户端发送数据"}},[t._v("#")]),t._v(" 6. 服务器向客户端发送数据")]),t._v(" "),s("blockquote",[s("p",[t._v("服务器向客户端发送头信息后，它会发送⼀个空⽩行来表示头信息的发送到此为结束，接着， 它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；")])]),t._v(" "),s("h5",{attrs:{id:"_7-服务器关闭-tcp-连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-服务器关闭-tcp-连接"}},[t._v("#")]),t._v(" 7. 服务器关闭 TCP 连接")]),t._v(" "),s("blockquote",[s("p",[t._v("⼀般情况下，⼀旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加⼊了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了⽹络带宽")])]),t._v(" "),s("h2",{attrs:{id:"http-协议有哪些特点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-协议有哪些特点？"}},[t._v("#")]),t._v(" HTTP 协议有哪些特点？")]),t._v(" "),s("h5",{attrs:{id:"_1-通过请求和响应的交换达成通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-通过请求和响应的交换达成通信"}},[t._v("#")]),t._v(" 1. 通过请求和响应的交换达成通信")]),t._v(" "),s("blockquote",[s("p",[t._v("协议规定，请求从客户端发出，服务端响应请求并返回。")])]),t._v(" "),s("h5",{attrs:{id:"_2-无状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-无状态"}},[t._v("#")]),t._v(" 2. 无状态")]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP 是⼀种"),s("strong",[t._v("无状态")]),t._v("协议，在单纯HTTP这个层面，协议对于发送过的请求或响应都不不做持久化处理")])]),t._v(" "),s("h5",{attrs:{id:"_3-使⽤-cookie-做状态管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-使⽤-cookie-做状态管理"}},[t._v("#")]),t._v(" 3. 使⽤ Cookie 做状态管理")]),t._v(" "),s("blockquote",[s("p",[t._v("服务端返回的头信息上有可能会携带Set-Cookie，那么当客户端接收到响应后，就会在本地种上 cookie。在下⼀次给服务端发送请求的时候，就会携带上这些 cookie")])]),t._v(" "),s("h5",{attrs:{id:"_4-通过url定位资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-通过url定位资源"}},[t._v("#")]),t._v(" 4. 通过URL定位资源")]),t._v(" "),s("blockquote",[s("p",[t._v("URI: 统⼀资源标识符，⽐如你身份证号是xxxxxxx，在所有人中是独⼀⽆二的，这个身份证号就能标识你的身份，那么它就是URI\nURL: 统一资源定位符，⽐如北京市/朝阳区/xxxx/xxxx/xxxxx，通过这⼀串信息可以定位到你，那么这个就是URL\nURL有点类似于通过定位实现的URI。\n就像有个父类叫做URI，他要实现的是唯一确定一个id。有的人喜欢继承URI，通过location来实现；有的⼈喜欢继承URI，通过name来实现。")])]),t._v(" "),s("h5",{attrs:{id:"_5-通过各种方法来标识⾃己的意图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-通过各种方法来标识⾃己的意图"}},[t._v("#")]),t._v(" 5. 通过各种方法来标识⾃己的意图")]),t._v(" "),s("blockquote",[s("p",[t._v("指的是各种HTTP方法，比如"),s("code",[t._v("GET、POST、PUT、DELETE")]),t._v("等。")])]),t._v(" "),s("h5",{attrs:{id:"_6-持久连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-持久连接"}},[t._v("#")]),t._v(" 6. 持久连接")]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP 协议的初始版本中，每进行⼀个 HTTP 通信都要断开⼀次 TCP 连接，增加了了很多没必要的建立连接的开销。\n为了解决上述 TCP 连接的问题，HTTP/1.1 ⽀持持久连接。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建⽴一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。\n也就是说_默认情况下建⽴ TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接_。")])]),t._v(" "),s("h5",{attrs:{id:"_7-管道机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-管道机制"}},[t._v("#")]),t._v(" 7. 管道机制")]),t._v(" "),s("blockquote",[s("p",[t._v("1.1 版本引⼊pipelining机制，即"),s("strong",[t._v("在同⼀个TCP连接里⾯，客户端可以同时发送多个请求")]),t._v("。\n举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。\n但是现代浏览器一般没开启这个配置，这个机制可能会造成队头阻塞。因为响应是有顺序的，如果⼀个TCP连接中的第一个HTTP请求响应非常慢，那么就会阻塞后续HTTP请求的响应。\n所以现实中默认情况下，一个TCP连接同一时间只发一个HTTP请求。")]),t._v(" "),s("p",[s("strong",[t._v("_chrome 最⼤支持6个同域名请求？ _")]),t._v("\n答：那是因为chrome最⼤支持同时开启6个TCP连接")])]),t._v(" "),s("h2",{attrs:{id:"http-1-0-1-1-2-0-在并发请求上主要区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-1-1-2-0-在并发请求上主要区别是什么"}},[t._v("#")]),t._v(" HTTP 1.0/1.1/2.0 在并发请求上主要区别是什么?")]),t._v(" "),s("h5",{attrs:{id:"_1-http-1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-http-1-0"}},[t._v("#")]),t._v(" 1. HTTP/1.0")]),t._v(" "),s("blockquote",[s("p",[t._v("每次TCP连接"),s("strong",[t._v("只能发送一个请求")]),t._v("，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接。")])]),t._v(" "),s("h5",{attrs:{id:"_2-http-1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-1-1"}},[t._v("#")]),t._v(" 2.  HTTP/1.1")]),t._v(" "),s("blockquote",[s("p",[t._v("默认采⽤"),s("strong",[t._v("持续连接")]),t._v("(TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive)\n增加了"),s("strong",[t._v("管道机制")]),t._v("，在同⼀个TCP连接里，允许多个请求同时发送，增加了并发性，进⼀步改善了HTTP协议的效率，\n但是同⼀个TCP连接⾥，所有的数据通信是按次序进行的。回应慢，会有许多请求排队，造成”"),s("strong",[t._v("队头堵塞")]),t._v("”。")])]),t._v(" "),s("h5",{attrs:{id:"_3-http-2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-http-2-0"}},[t._v("#")]),t._v(" 3.  HTTP/2.0")]),t._v(" "),s("blockquote",[s("p",[t._v("加了"),s("strong",[t._v("双工模式")]),t._v("，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题。\n使⽤了"),s("strong",[t._v("多路复用")]),t._v("的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1 大了好几个数量级，增加了服务器推送的功能，不 经请求服务端主动向客户端发送数据。")])]),t._v(" "),s("h2",{attrs:{id:"headers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#headers"}},[t._v("#")]),t._v(" Headers")]),t._v(" "),s("h3",{attrs:{id:"cache-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),s("blockquote",[s("p",[t._v("通过指定首部字段 Cache-Control 的指令，就能操作缓存的⼯作机制")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("Cache-Control: public")])])]),t._v(" "),s("blockquote",[s("p",[t._v("当指定使⽤ public 指令时，则明确表明其他用户也可利用缓存。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("strong",[t._v("Cache-Control: private")])])]),t._v(" "),s("blockquote",[s("p",[t._v("当指定 private 指令后，响应只以特定的⽤用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他⽤户发送过来的请求，代理服务器则不会返回缓存。")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("strong",[t._v("Cache-Control: no-cache")])])]),t._v(" "),s("blockquote",[s("p",[t._v("可以在客户端存储资源，每次都必须去服务端做过期校验，来决定从服务端获取新的资源 （200）还是使用客户端缓存（304）。也就是所谓的协商缓存。")])]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("strong",[t._v("Cache-Control: no-store")])])]),t._v(" "),s("blockquote",[s("p",[t._v("永远都不要在客户端存储资源，永远都去原始服务器去获取资源。")])]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[s("strong",[t._v("Cache-Control: max-age=604800（单位：秒）")])])]),t._v(" "),s("blockquote",[s("p",[t._v("当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值⽐比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。\nHTTP/1.1 版本的缓存服务器遇到同时存在 Expires ⾸部字段的情况时，会优先处理理 max-age 指令，并忽略掉 Expires ⾸部字段")])]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[s("strong",[t._v("Cache-Control: s-maxage=604800（单位：秒）")])])]),t._v(" "),s("blockquote",[s("p",[t._v("s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使⽤的公共缓存服务器（一般指代理）\n当使⽤ s-maxage 指令后，则直接忽略对 Expires ⾸部字段及 max-age 指令的处理")])]),t._v(" "),s("h3",{attrs:{id:"connection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#connection"}},[t._v("#")]),t._v(" Connection")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("Connection: close")])])]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("strong",[t._v("Connection: Keep-Alive")])])]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP/1.1 之前的 HTTP 版本的默认连接都是⾮持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection ⾸部字段的值为 Keep-Alive。")])]),t._v(" "),s("h3",{attrs:{id:"date"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#date"}},[t._v("#")]),t._v(" Date")]),t._v(" "),s("blockquote",[s("p",[t._v("表明创建 HTTP 报⽂的日期和时间。")])]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Date:")]),t._v(" Mon, 10 Jul 2021 15:50:06 GMT\n")])])]),s("p",[t._v("HTTP/1.1 协议使⽤在 RFC1123 中规定的⽇期时间的格式。")]),t._v(" "),s("h3",{attrs:{id:"pragma"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pragma"}},[t._v("#")]),t._v(" Pragma")]),t._v(" "),s("blockquote",[s("p",[t._v("Pragma ⾸部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容⽽定义。")])]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Pragma:")]),t._v(" no-cache\n")])])]),s("blockquote",[s("p",[t._v("该首部字段属于通用⾸部字段，但只用在客户端发送的请求中，要求所有的中间服务器器不返回缓存的资源。\n所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理⽅式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下⾯两个首部字段：\n"),s("code",[t._v("Cache-Control: no-cache")]),t._v(" "),s("code",[t._v("Pragma: no-cache")])])]),t._v(" "),s("h3",{attrs:{id:"accept"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accept"}},[t._v("#")]),t._v(" Accept")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept:")]),t._v(" text/html，application/xhtml+xml, application/xml;\n")])])]),s("blockquote",[s("p",[t._v("Accept 首部字段可通知服务器，⽤户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，⼀次指定多种媒体类型。")])]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept-Encoding:")]),t._v(" gzip, deflate\n")])])]),s("blockquote",[s("p",[t._v("Accept-Encoding ⾸部字段⽤来告知服务器用户代理支持的内容编码及内容编码的优先顺序， 并可一次性指定多种内容编码。\n也可使用星号（*）作为通配符，指定任意的编码格式。")]),t._v(" "),s("ul",[s("li",[t._v("gzip")])]),t._v(" "),s("p",[t._v("表明实体采⽤ GNU zip 编码")]),t._v(" "),s("ul",[s("li",[t._v("compress")])]),t._v(" "),s("p",[t._v("表明实体采用 Unix 的⽂件压缩程序")]),t._v(" "),s("ul",[s("li",[t._v("deflate")])]),t._v(" "),s("p",[t._v("表明实体采用 zlib 的格式压缩的")]),t._v(" "),s("ul",[s("li",[t._v("identity")])]),t._v(" "),s("p",[t._v("表明没有对实体进⾏编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式")])]),t._v(" "),s("h3",{attrs:{id:"host"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#host"}},[t._v("#")]),t._v(" Host")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v(" Host: www.baidu.com\n")])])]),s("blockquote",[s("p",[t._v("告知服务器，请求的资源所处的互联⽹主机和端⼝号。\nHost ⾸部字段是 HTTP/1.1 规范内唯⼀一个必须被包含在请求内的首部字段。\n若服务器未设定主机名，那直接发送一个空值即可 Host: 。")])]),t._v(" "),s("h3",{attrs:{id:"if-modified-since"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#if-modified-since"}},[t._v("#")]),t._v(" If-Modified-Since")]),t._v(" "),s("blockquote",[s("p",[t._v("形如 If-xxx 这种样式的请求⾸部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。")])]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("If-Modified-Since:")]),t._v(" Mon, 10 Jul 2021 15:50:06 GMT \n")])])]),s("blockquote",[s("p",[t._v("用于确认代理或客户端拥有的本地资源的有效性。\n在指定 If-Modified-Since 字段值的⽇期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。")])]),t._v(" "),s("h3",{attrs:{id:"etag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[t._v("#")]),t._v(" ETag")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v(" ETag: “aaaa-1234”\n")])])]),s("blockquote",[s("p",[t._v("⾸部字段 ETag 能告知客户端实体标识。它是⼀种可将资源以字符串形式做唯⼀性标识的⽅式。服务器会为每份资源分配对应的 ETag 值。\n另外，当资源更新时，ETag 值也需要更新。⽣成 ETag 值时，并没有统⼀的算法规则，⽽仅仅是由服务器来分配。")])]),t._v(" "),s("h3",{attrs:{id:"if-none-match"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#if-none-match"}},[t._v("#")]),t._v(" If-None-Match")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("If-None-Match:")]),t._v(" “lubai”\n")])])]),s("blockquote",[s("p",[t._v("⽤于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。")])]),t._v(" "),s("h3",{attrs:{id:"user-agent"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#user-agent"}},[t._v("#")]),t._v(" User-Agent")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("User-Agent:")]),t._v(" Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\n")])])]),s("blockquote",[s("p",[t._v("⾸部字段 User-Agent 会将创建请求的浏览器和⽤户代理名称等信息传达给服务器。\n由⽹络爬⾍发起请求时，有可能会在字段内添加爬⾍作者的电⼦邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。")])]),t._v(" "),s("h3",{attrs:{id:"allow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#allow"}},[t._v("#")]),t._v(" Allow")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Allow:")]),t._v(" GET, HEAD\n")])])]),s("blockquote",[s("p",[t._v("⾸部字段 Allow ⽤于通知客户端能够⽀持 Request-URI 指定资源的所有 HTTP ⽅法。\n当服务器接收到不⽀持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入⾸部字段 Allow 后返回。")])]),t._v(" "),s("h3",{attrs:{id:"content-encoding"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#content-encoding"}},[t._v("#")]),t._v(" Content-Encoding")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Content-Encoding:")]),t._v(" gzip\n")])])]),s("blockquote",[s("p",[t._v("⾸部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码⽅式。内容编码是指在不丢失实体信息的前提下所进行的压缩。")])]),t._v(" "),s("h3",{attrs:{id:"content-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#content-type"}},[t._v("#")]),t._v(" Content-Type")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Content-Type:")]),t._v(" text/html; charset=UTF-8\n")])])]),s("blockquote",[s("p",[t._v("首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept ⼀样，字段值用 type/subtype 形式赋值。")])]),t._v(" "),s("h3",{attrs:{id:"expires"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Expires:")]),t._v(" Mon, 10 Jul 2021 15:50:06 GMT\n")])])]),s("blockquote",[s("p",[t._v("⾸部字段 Expires 会将资源失效的日期告知客户端。\n缓存服务器在接收到含有⾸部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会⼀直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。")])]),t._v(" "),s("h3",{attrs:{id:"set-cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set-cookie"}},[t._v("#")]),t._v(" Set-Cookie")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Set-Cookie:")]),t._v(" userId=11111; expires=Mon, 10 Jul 20121 15:50:06 GMT; path=/;\n")])])]),s("blockquote",[s("ul",[s("li",[s("strong",[t._v("NAME=VALUE")]),t._v(": cookie名称和值")]),t._v(" "),s("li",[s("strong",[t._v("expires=DATE:")]),t._v(" Cookie 的有效期（若不明确指定则默认为浏览器关闭前为⽌止）")]),t._v(" "),s("li",[s("strong",[t._v("path=PATH")]),t._v(": ⽤于限制指定 Cookie 的发送范围的文件⽬目录。")]),t._v(" "),s("li",[s("strong",[t._v("domain=域名")]),t._v(": cookie有效的域名  （若不指定则默认为创建 Cookie的服务器的域名）")]),t._v(" "),s("li",[s("strong",[t._v("Secure")]),t._v(": 仅在 HTTPS 安全通信时才会发送 Cookie")]),t._v(" "),s("li",[s("strong",[t._v("HttpOnly")]),t._v(": 使 Cookie 不能被 JavaScript 脚本访问")])])]),t._v(" "),s("h2",{attrs:{id:"http-缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存机制"}},[t._v("#")]),t._v(" HTTP 缓存机制")]),t._v(" "),s("h3",{attrs:{id:"强制缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),s("blockquote",[s("p",[t._v("在浏览器内置数据库中缓存每次请求中 “"),s("strong",[t._v("可以被缓存")]),t._v("” （受到一些关键字的管控）的静态资源如 image, css, js 文件， 当第二次请求被缓存过的资源时候，会通过校验两个字段 "),s("strong",[t._v("Expires")]),t._v(" 和 "),s("strong",[t._v("Cache-Control")]),t._v(" 的 "),s("strong",[t._v("max-age")]),t._v(" 字段（注意，Expires 是 http1.0 的产物， Cache-Control 则是 http1.1 的产物。 两者同时存在， 或者只存在其中之一， 都可以触发强制缓存）")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/jpeg/544886/1670160097068-71d900fa-d8a1-4327-b4bb-b1c0b0681c9d.jpeg",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("当两个字段同时存在得到时候， "),s("em",[s("strong",[t._v("Cache-Control")])]),t._v(" 中的 _**max-age "),s("strong",[t._v("_字段字段")]),s("em",[t._v("优先级")]),t._v("**会稍微高一点， 当 "),s("em",[s("strong",[t._v("Cache-Control")])]),t._v(" 中的 _**max-age **_字段校验成功，会直接返回浏览器内置数据库的缓存， 失效时才会将决策权传递给 _**Expires **_字段判断。\n大概是因为 Expires 字段在设计时存在了这么一个缺陷——Expires字段返回的是服务器的时间， 而非客户端的本机时间。 当存在时差， 或者客户修改本地时间的情况下 Expires 字段会存在失效的可能性，比如当同一时刻下的服务器时间为 2022/4/26 06:00:00 客户端时间为 2022/4/26 12:00:00 过期时间为两个小时之后， 则服务器会返回 2022/4/26 08:00:00 这个时间对应的值。由于浏览器运行在客户环境下，对于客户而言， 这个缓存已经过期了，虽然缓存确实有效， 但是对于浏览器而言这个缓存确确实实是 “过期了”， 这会导致强制缓存永远不会生效。\n那么为了解决这个问题， _**http 1.1 **_协议中添加了 "),s("em",[s("strong",[t._v("Cache-Control")])]),t._v(" 中的 "),s("em",[s("strong",[t._v("max-age")])]),t._v("， 他是一个相对值， 即客户端获取到这个文件多少秒后失效， 其判别权力全权交由浏览器， 这会相对更准确些。")])]),t._v(" "),s("h3",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("blockquote",[s("p",[t._v("协商缓存主要由 "),s("strong",[t._v("ETag")]),t._v(" 和 "),s("strong",[t._v("Last-Modified")]),t._v(" 两个字段来实现")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("ETag")]),t._v(" 是一个用于映射 web 资源的映射 token，这个 token 应该满足唯一对应到一 个web服务器上的静态资源（具体实现通常是提取文件相关信息进行hash和base64编码等操作）对应 "),s("em",[s("strong",[t._v("If-None-Match")])])]),t._v(" "),s("li",[s("strong",[t._v("Last-Modified")]),t._v(" 则通常是文件最后更新的日期时间戳，对应 "),s("em",[s("strong",[t._v("If-Modified-Since")])])])]),t._v(" "),s("p",[t._v("（通过上述两个字段就可以判断当前文件是否是最新的数据）")])]),t._v(" "),s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" "),s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/jpeg/544886/1670160029875-8a8ba469-a05d-41f9-9bca-66e7c27a7b11.jpeg",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("浏览器首次向服务器请求数据 A， 服务器正常返回数据，同时在响应头中放入 "),s("strong",[s("em",[t._v("ETag")])]),t._v(" 和 "),s("em",[s("strong",[t._v("Last-Modified")])]),t._v(" 两个新字段。\n当浏览器第二次向服务器请求数据 A 时， 浏览器会自动地在请求头附上 If-None-Match 和 If-Modified-Since 两个字段（分别对应的是 ETag 和 Last-Modified 的值，两两相等）， 然后由服务器端进行校验， 校验通过的话（表明数据有效）， 服务器会直接返回状态码 304 ，且不携带响应体的报文段， 这相当于告诉浏览器：当前缓存有效， 可以直接使用！ 校验失败则会和首次请求一样， 返回状态码为200且携带数据响应体的报文段， 同时这个响应头会带上新的ETag 和Last-Modified， 为下一次协商缓存做好铺垫 。\n需要注意的是， 在不用框架的情况下， 协商缓存需要由后端开发人员手动实现，因此 ETag 和 Last-Modified 两个字段的优先级取决于开发者， 但是 Last-Modified 这个字段可以记录的时间戳精确度是有一定限制的，如果连续多次数据更新在精确度范围外， 会产生精确度丢失， 因此通常会让 "),s("strong",[t._v("ETag 的优先级高于 Last-Modified")]),t._v(" 字段（类似于Cache-control中max-age一样， 属于是后续改进协议的一个新字段， 因此优先级一般会高点)")])]),t._v(" "),s("h3",{attrs:{id:"强制缓存-协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存-协商缓存"}},[t._v("#")]),t._v(" 强制缓存 + 协商缓存")]),t._v(" "),s("blockquote",[s("p",[t._v("默认情况下， "),s("strong",[t._v("浏览器会优先考量强制缓存的情况")]),t._v("， 当强制缓存生效的情况下， 请求并不会到达服务器， 因此也就不会触发协商缓存。 当强制缓存失效的时候， 浏览器便会将请求传递到服务器， 于是服务器又会开始校验 If-Modified-Since 和 If-None-Match 两个字段， 重复上述协商缓存的一个执行流程\n乍一看，两者并存的情况， 有点像是两个协议的简单叠加，此时的协商缓存更像是强制缓存的兜底策略， 很可能协商缓存很长一段时间都不会生效（强制缓存过期时间设置过长的情况下）， 因为"),s("strong",[t._v("强制缓存的优先级是要高于协商缓存")]),t._v("的。 当然这并不是我们想看到的， 比方说当后端数据确实变更了， 而此时的浏览器由于使用了强制缓存，则会出现数据不一致的情况， 因此在这里引入了请求头中的两个字段 "),s("strong",[t._v("no-cache")]),t._v("， 当使用了 no-cache 字段的时候， 浏览器将不再使用强制缓存， 而是直接去请求服务器， 这个时候就会用到协商缓存了（顺带一提的是， 还有一个 **no-store **字段， 用了这个字段浏览器则不会在使用缓存的数据也不缓存数据，即强制缓存和协商缓存都失效了）")])]),t._v(" "),s("h2",{attrs:{id:"使用-nodejs-创建-http-服务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-nodejs-创建-http-服务"}},[t._v("#")]),t._v(" 使用 NodeJS 创建 HTTP 服务")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" http "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'http'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nhttp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createServer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("req"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" res")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("writeHead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Content-Type'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'text/plain'")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello World'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("listen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'127.0.0.1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Server running at http://127.0.0.1:80/'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" http "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'http'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" options "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    hostname"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'127.0.0.1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    port"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    path"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    method"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'GET'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" req "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" http"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("request")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("options"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("Status=")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("statusCode"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v(", Headers=$ \n{JSON.stringify(res.headers)}")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setEncoding")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'utf8'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'data'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nreq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("end")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);