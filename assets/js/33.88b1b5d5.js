(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{646:function(t,s,e){"use strict";e.r(s);var a=e(0),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",[t._v("一个合格的前端架构需要考虑的不仅仅是能够写代码，更要以大局来规范项目。我认为规范制定，模块化管理，组件管理是必须要掌握的。")])]),t._v(" "),e("h2",{attrs:{id:"规范制定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#规范制定"}},[t._v("#")]),t._v(" 规范制定")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("首先要考虑的是规范的问题，制定一个规范的标准，可以让自己和团队程序员更加容易理解代码、梳理逻辑，也能让程序员保持良好的心情 。")])]),t._v(" "),e("h3",{attrs:{id:"eslint（standard-airbnd-prettier）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eslint（standard-airbnd-prettier）"}},[t._v("#")]),t._v(" Eslint（standard/Airbnd/prettier）")]),t._v(" "),e("blockquote",[e("p",[t._v("在开发环境制定统一的eslint标准（.eslintrc.js/.eslintrc.json文件），加上vscode的配置，保存即格式化代码。")])]),t._v(" "),e("h3",{attrs:{id:"命名规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命名规范"}},[t._v("#")]),t._v(" 命名规范")]),t._v(" "),e("blockquote",[e("ul",[e("li",[e("p",[t._v("文件夹命名规范")]),t._v(" "),e("ul",[e("li",[t._v("使用统一小写英文字母(统一翻译的英文名字), 数字和中划线的组合，不得包含汉字, 空格和特殊字符")]),t._v(" "),e("li",[t._v("常用命名文件夹")])])]),t._v(" "),e("li",[e("p",[t._v("文件命名规范")]),t._v(" "),e("ul",[e("li",[t._v("使用统一小写的英文字母(统一翻译的英文名字)， 数字和中划线的组合， 不得包含汉字，空格和特殊字符")]),t._v(" "),e("li",[t._v("使用英文句号表示文件依赖关系, 范围大的在前面")]),t._v(" "),e("li",[t._v("经过压缩的文件添加min")]),t._v(" "),e("li",[t._v("使用数字代表版本号")])])]),t._v(" "),e("li",[e("p",[t._v("变量命名规范")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("常量命名：全部大写并单词间用下划线分隔，如：CSS_BTN_CLOSE、TXT_LOADING")])]),t._v(" "),e("li",[e("p",[t._v("对象的属性、变量名、方法名、函数名：小驼峰式如：init、bindEvent、updatePosition")])]),t._v(" "),e("li",[e("p",[t._v("类名（构造器）：大驼峰式如：Current、DefaultConfig")])]),t._v(" "),e("li",[e("p",[t._v("私有变量名：小驼峰式但需要用_开头如：_current、_defaultConfig")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("props")]),t._v("：小驼峰式并在模板中使用短横线命名来访问 props如：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" PopupWindow title"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("‘hello’"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" \nprops"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" titleText"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("String"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])])])])]),t._v(" "),e("h3",{attrs:{id:"统一文件管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#统一文件管理"}},[t._v("#")]),t._v(" 统一文件管理")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("assets：子文件夹images和styles、存放图片和样式")]),t._v(" "),e("li",[t._v("utils：存放一些工具类的js模块，例如http请求的封装、日期格式化的方法、校验规则正则等")]),t._v(" "),e("li",[t._v("filters：存放全局过滤器方法。")]),t._v(" "),e("li",[t._v("directive：存放全局自定义指令。")]),t._v(" "),e("li",[t._v("comonpents：存放全局组件。")]),t._v(" "),e("li",[t._v("config/constants：存放全局常量的定义、比如统一的接口成功失败的提示语、枚举值等根据项目决定。")]),t._v(" "),e("li",[t._v("mixins：可以用来存放一些通用功能。")]),t._v(" "),e("li",[t._v("views、router、store比较常用，就不介绍了。")])])]),t._v(" "),e("h2",{attrs:{id:"模块化管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化管理"}},[t._v("#")]),t._v(" 模块化管理")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("如上述的统一文件管理，常用到的一些方法、常量写在别的文件里，那我们如何去用这些方法呢。这就是需要掌握的模块化。需要模块化开发的概念用来提升开发效率和方便后期维护。")])]),t._v(" "),e("h3",{attrs:{id:"commonjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[t._v("#")]),t._v(" commonJS")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("用法")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" v  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//导出")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" v "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引入")]),t._v("\n")])])])]),t._v(" "),e("li",[e("p",[t._v("总结")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。")]),t._v(" "),e("li",[t._v("对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。")]),t._v(" "),e("li",[t._v("当使用require命令加载某个模块时，就会运行整个模块的代码。")]),t._v(" "),e("li",[t._v("当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。")]),t._v(" "),e("li",[t._v('循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。')])])])])]),t._v(" "),e("h3",{attrs:{id:"es6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("用法")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//导出")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" b"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引入")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n")])])]),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//导出")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" v"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引入")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" v "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" c "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n")])])])]),t._v(" "),e("li",[e("p",[t._v("总结")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("ES6模块中的值属于【动态只读引用】。")]),t._v(" "),e("li",[t._v("对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。")]),t._v(" "),e("li",[t._v("对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。")]),t._v(" "),e("li",[t._v("循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。")])])])])]),t._v(" "),e("h3",{attrs:{id:"commonjs-和es6-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-和es6-区别"}},[t._v("#")]),t._v(" CommonJS 和ES6 区别")]),t._v(" "),e("blockquote",[e("p",[t._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")])]),t._v(" "),e("h2",{attrs:{id:"组件管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件管理"}},[t._v("#")]),t._v(" 组件管理")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[t._v("组件又分为UI组件和业务组件，对于UI组件，可以使用UI组件库，或者封装为全局组件。业务组件根据项目的业务拆分一些使用频率较高的部分，或者一些和主页面展现的业务耦合度很低的页面，封装为组件。提升代码的复用率和方便后期维护。")])]),t._v(" "),e("h3",{attrs:{id:"组件-props-原子化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件-props-原子化"}},[t._v("#")]),t._v(" 组件 props 原子化")]),t._v(" "),e("p",[t._v("虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 "),e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/Primitive",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 原始类型"),e("OutboundLink")],1),t._v("（字符串、数字、布尔值）和函数。尽量避免复杂的对象。原因：")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("使得组件 API 清晰直观。")]),t._v(" "),e("li",[t._v("只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。")]),t._v(" "),e("li",[t._v("其它开发者更好的理解每一个 prop 的含义、作用。")]),t._v(" "),e("li",[t._v("传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。")])])]),t._v(" "),e("h3",{attrs:{id:"验证组件的-props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#验证组件的-props"}},[t._v("#")]),t._v(" 验证组件的 props")]),t._v(" "),e("p",[t._v("组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串("),e("code",[t._v(':attr="value"')]),t._v(" 或 "),e("code",[t._v('v-bind:attr="value"')]),t._v(")或是不传。你需要保证组件的 props 能应对不同的情况。验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("提供默认值。")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("type")]),t._v(" 属性"),e("a",{attrs:{href:"http://vuejs.org/v2/guide/components.html#Prop-Validation",target:"_blank",rel:"noopener noreferrer"}},[t._v("校验类型"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("li",[t._v("使用 props 之前先检查该 prop 是否存在。")])])]),t._v(" "),e("h3",{attrs:{id:"将-this-赋值给-component-变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#将-this-赋值给-component-变量"}},[t._v("#")]),t._v(" 将 "),e("code",[t._v("this")]),t._v(" 赋值给 "),e("code",[t._v("component")]),t._v(" 变量")]),t._v(" "),e("p",[t._v("在 Vue.js 组件上下文中，"),e("code",[t._v("this")]),t._v("指向了组件实例。因此当你切换到了不同的上下文时，要确保 "),e("code",[t._v("this")]),t._v(" 指向一个可用的 "),e("code",[t._v("component")]),t._v(" 变量。")]),t._v(" "),e("p",[t._v("换句话说，如果你正在使用 "),e("strong",[t._v("ES6")]),t._v(" 的话，就不要再编写 "),e("code",[t._v("var self = this;")]),t._v(" 这样的代码了，您可以安全地使用 Vue 组件")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("使用 "),e("strong",[t._v("ES6")]),t._v("，就不再需要将 "),e("code",[t._v("this")]),t._v(" 保存到一个变量中了。")]),t._v(" "),e("li",[t._v("一般来说，当你使用箭头函数时，会保留 "),e("code",[t._v("this")]),t._v(" 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。）")]),t._v(" "),e("li",[t._v("如果你没有使用 "),e("strong",[t._v("ES6")]),t._v("，当然也就不会使用 "),e("code",[t._v("箭头函数")]),t._v(" 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。")])])]),t._v(" "),e("h3",{attrs:{id:"组件结构化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件结构化"}},[t._v("#")]),t._v(" 组件结构化")]),t._v(" "),e("p",[t._v("按照一定的结构组织，使得组件便于理解。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。")]),t._v(" "),e("li",[t._v("按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。")]),t._v(" "),e("li",[t._v("合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("name")]),t._v(" 属性。借助于 "),e("a",{attrs:{href:"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue devtools"),e("OutboundLink")],1),t._v(" 可以让你更方便的测试。")]),t._v(" "),e("li",[t._v("合理的 CSS 结构，如 "),e("a",{attrs:{href:"https://medium.com/tldr-tech/bem-blocks-elements-and-modifiers-6b3b0af9e3ea#.bhnomd7gw",target:"_blank",rel:"noopener noreferrer"}},[t._v("BEM"),e("OutboundLink")],1),t._v(" 或 "),e("a",{attrs:{href:"https://github.com/rstacruz/rscss",target:"_blank",rel:"noopener noreferrer"}},[t._v("rscss"),e("OutboundLink")],1),t._v(" - "),e("a",{attrs:{href:"https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md#%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%90%8D%E4%BD%9C%E4%B8%BA%E6%A0%B7%E5%BC%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%A9%BA%E9%97%B4",target:"_blank",rel:"noopener noreferrer"}},[t._v("详情？"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("li",[t._v("使用单文件 .vue 文件格式来组件代码。")])])]),t._v(" "),e("h4",{attrs:{id:"组件事件命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件事件命名"}},[t._v("#")]),t._v(" 组件事件命名")]),t._v(" "),e("p",[t._v("Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少的开发问题")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("事件名也使用连字符命名。")]),t._v(" "),e("li",[t._v("一个事件的名字对应组件外的一组意义操作，如：upload-success、upload-error 以及 dropzone-upload-success、dropzone-upload-error （如果需要前缀的话）。")]),t._v(" "),e("li",[t._v("事件命名应该以动词（如 client-api-load） 或是 名词（如 drive-upload-success）结尾。")])])]),t._v(" "),e("h3",{attrs:{id:"避免-this-parent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免-this-parent"}},[t._v("#")]),t._v(" 避免 this.$parent")]),t._v(" "),e("p",[t._v("组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("通过 props 将值传递给子组件。")]),t._v(" "),e("li",[t._v("通过 props 传递回调函数给子组件来达到调用父组件方法的目的。")]),t._v(" "),e("li",[t._v("通过在子组件触发事件来通知父组件。")])])]),t._v(" "),e("h3",{attrs:{id:"谨慎使用-this-refs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谨慎使用-this-refs"}},[t._v("#")]),t._v(" 谨慎使用 this.$refs")]),t._v(" "),e("p",[t._v("组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。组件的属性和事件必须足够的给大多数的组件使用。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("提供良好的组件 API。")]),t._v(" "),e("li",[t._v("总是关注于组件本身的目的。")]),t._v(" "),e("li",[t._v("拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。")]),t._v(" "),e("li",[t._v("检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。")]),t._v(" "),e("li",[t._v("检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。")]),t._v(" "),e("li",[e("strong",[t._v("Props向下传递，事件向上传递！")]),t._v("。以此为目标升级你的组件，提供良好的 API 和 独立性。")]),t._v(" "),e("li",[t._v("当遇到 props 和 events 难以实现的功能时，通过 "),e("code",[t._v("this.$refs")]),t._v("来实现。")]),t._v(" "),e("li",[t._v("当需要操作 DOM 无法通过指令来做的时候可使用 "),e("code",[t._v("this.$ref")]),t._v(" 而不是 "),e("code",[t._v("JQuery")]),t._v("、"),e("code",[t._v("document.getElement*")]),t._v("、"),e("code",[t._v("document.queryElement")]),t._v("。")])])]),t._v(" "),e("h3",{attrs:{id:"使用组件名作为样式作用域空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用组件名作为样式作用域空间"}},[t._v("#")]),t._v(" 使用组件名作为样式作用域空间")]),t._v(" "),e("p",[t._v("给样式加上作用域空间可以避免组件样式影响外部的样式。保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。")]),t._v(" "),e("li",[t._v("加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。")])])]),t._v(" "),e("h3",{attrs:{id:"只在需要时创建组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#只在需要时创建组件"}},[t._v("#")]),t._v(" 只在需要时创建组件")]),t._v(" "),e("p",[t._v("Vue.js 是一个基于组件的框架。如果你不知道何时创建组件可能会导致以下问题：")]),t._v(" "),e("ul",[e("li",[t._v("如果组件太大, 可能很难重用和维护;")]),t._v(" "),e("li",[t._v("如果组件太小，你的项目就会（因为深层次的嵌套而）被淹没，也更难使组件间通信;")])]),t._v(" "),e("p",[t._v("始终记住为你的项目需求构建你的组件，但是你也应该尝试想到它们能够从中脱颖而出（独立于项目之外）。如果它们能够在你项目之外工作，就像一个库那样，就会使得它们更加健壮和一致。尽可能早地构建你的组件总是更好的，因为这样使得你可以在一个已经存在和稳定的组件上构建你的组件间通信（props & events）")]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("首先，尽可能早地尝试构建出诸如模态框、提示框、工具条、菜单、头部等这些明显的（通用型）组件。总之，你知道的这些组件以后一定会在当前页面或者是全局范围内需要。")]),t._v(" "),e("li",[t._v("第二，在每一个新的开发项目中，对于一整个页面或者其中的一部分，在进行开发前先尝试思考一下。如果你认为它有一部分应该是一个组件，那么就创建它吧。")]),t._v(" "),e("li",[t._v("最后，如果你不确定，那就不要。避免那些“以后可能会有用”的组件污染你的项目。它们可能会永远的只是（静静地）待在那里，这一点也不聪明。注意，一旦你意识到应该这么做，最好是就把它打破，以避免与项目的其他部分构成兼容性和复杂性。")])])]),t._v(" "),e("h3",{attrs:{id:"尽可能使用-mixins"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#尽可能使用-mixins"}},[t._v("#")]),t._v(" 尽可能使用 mixins")]),t._v(" "),e("p",[t._v("Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。")])])}),[],!1,null,null,null);s.default=r.exports}}]);