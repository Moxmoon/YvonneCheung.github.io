(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{641:function(_,v,e){"use strict";e.r(v);var s=e(0),t=Object(s.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",[_._v("读《Node.js 深入浅出》")])]),_._v(" "),e("h2",{attrs:{id:"模块机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块机制"}},[_._v("#")]),_._v(" 模块机制")]),_._v(" "),e("h3",{attrs:{id:"_1-1-commonjs规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-commonjs规范"}},[_._v("#")]),_._v(" 1.1 CommonJS规范")]),_._v(" "),e("blockquote",[e("p",[e("strong",[_._v("希望Javascript能够在任何地方运行")]),_._v("。希望用CommonJS API写出额的应用可以具备跨宿主环境执行的能力，这样不仅可以开发富客户端应用，而且还可以编写服务器端JS应用程序、命令行工具、桌面图形界面应用程序、混合应用（Titanium和Adobe AIR等形式的应用）")])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("规范包含")]),_._v(" "),e("blockquote",[e("p",[_._v("模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。")])])])]),_._v(" "),e("h3",{attrs:{id:"_1-2-commonjs模块规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-commonjs模块规范"}},[_._v("#")]),_._v(" 1.2 CommonJS模块规范")]),_._v(" "),e("h4",{attrs:{id:"模块引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块引用"}},[_._v("#")]),_._v(" 模块引用")]),_._v(" "),e("p",[e("em",[e("strong",[_._v("require")])]),_._v("() 方法，接收模块标识，以此引入一个模块的API到当前上下文中。")]),_._v(" "),e("h4",{attrs:{id:"模块定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块定义"}},[_._v("#")]),_._v(" 模块定义")]),_._v(" "),e("p",[_._v("在模块中，上下文提供require() 方法来引入外部模块。对应的引入功能，提供了***exports***对象用于到处当前的方法或者变量，并且它是唯一导出的出口。还存在一个module对象，它代表模块自身，而exports是module的属性。")]),_._v(" "),e("h4",{attrs:{id:"模块标识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块标识"}},[_._v("#")]),_._v(" 模块标识")]),_._v(" "),e("p",[_._v("传递给require() 方法的参数，必须符合小驼峰命名的字符串，或者以 . 、.. 开头的相对路径，或者绝对路径。它可以没有文件名后缀.js")]),_._v(" "),e("p",[_._v("PS：不必考虑变量污染。每个模块都具有独立的空间。")]),_._v(" "),e("h2",{attrs:{id:"node的模块实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node的模块实现"}},[_._v("#")]),_._v(" Node的模块实现")]),_._v(" "),e("blockquote",[e("p",[_._v("Node引入模块需要经历 路径分析、文件定位、编译执行 三个步骤。")])]),_._v(" "),e("ul",[e("li",[e("p",[e("strong",[_._v("核心模块（Node提供的模块）")])]),_._v(" "),e("p",[_._v("核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中"),e("strong",[_._v("优先判断")]),_._v("，所以加载速度最快。")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("文件模块（用户编写的模块）")])]),_._v(" "),e("p",[_._v("在运行时动态加载，需要完整的三个步骤，速度比核心模块慢。")])])]),_._v(" "),e("h3",{attrs:{id:"_2-1-优先从缓存加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-优先从缓存加载"}},[_._v("#")]),_._v(" 2.1 优先从缓存加载")]),_._v(" "),e("p",[_._v("与浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存。")]),_._v(" "),e("p",[_._v("浏览器仅仅缓存文件，而"),e("strong",[_._v("Node缓存的是编译和执行之后的对象")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"_2-2-路径分析和文件定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-路径分析和文件定位"}},[_._v("#")]),_._v(" 2.2 路径分析和文件定位")]),_._v(" "),e("ol",[e("li",[e("p",[e("strong",[_._v("模块标识符分析")])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("核心模块")]),_._v(" "),e("p",[_._v("核心模块优先级 < 缓存加载")])]),_._v(" "),e("li",[e("p",[_._v("路径形式的文件模块")]),_._v(" "),e("p",[_._v("在分析文件模块时，require方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。")])]),_._v(" "),e("li",[e("p",[_._v("自定义模块")]),_._v(" "),e("p",[_._v("最费时，也是最慢的一种。")]),_._v(" "),e("p",[_._v("当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。")])])])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("文件定位")])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("文件扩展名分析")]),_._v(" "),e("p",[_._v("Node会按.js、.json、.node的次序补足扩展名，依次尝试，在尝试的过程种，需要调用fs模块同步阻塞式地判断文件是否存在。"),e("strong",[_._v("同步配合缓存")]),_._v("，可以大幅度缓解Node单线程种阻塞式调用的缺陷。")])]),_._v(" "),e("li",[e("p",[_._v("目录分析和包")]),_._v(" "),e("pre",[e("code",[_._v("   通过分析文件扩展名，可能没有查找到对应的文件，但却得到一个目录，Node会将目录当作一个包处理。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。\n\n   而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index\n")])]),_._v(" "),e("p",[_._v("当作默认文件名，然后依次查找index.js、index.json、index.node。如果没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找，如果所有的模块路径数组都遍历完毕依然没有找到目标文件，则会抛出查找失败。")])])])])]),_._v(" "),e("h3",{attrs:{id:"_2-3-模块编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-模块编译"}},[_._v("#")]),_._v(" 2.3 模块编译")]),_._v(" "),e("p",[_._v("编译和执行是引入文件模块的最后一个阶段，定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对不同的文件扩展名，其载入方法也有所不同。")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v(".js文件")]),_._v("：通过fs模块同步读取文件后编译执行。")]),_._v(" "),e("li",[_._v("."),e("strong",[_._v("node文件")]),_._v("：这是用C/C++编写的扩展文件。通过dlopen()方法加载最后编译生成的文件。")]),_._v(" "),e("li",[e("strong",[_._v(".json文件")]),_._v("：通过fs模块同步读取文件后，用JSON.parse()解析返回结果。")]),_._v(" "),e("li",[e("strong",[_._v("其余扩展名文件")]),_._v("：都被当作.js文件载入。")])]),_._v(" "),e("p",[_._v("每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入性能。")]),_._v(" "),e("p",[_._v("Module._extensions会被赋值给require的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式。")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("JavaScript模块的编译")]),_._v(" "),e("p",[_._v("exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改变形参的引用。")])]),_._v(" "),e("li",[e("p",[_._v("C/C++模块的编译")]),_._v(" "),e("p",[_._v("Node调用process.dlopen()方法进行加载和执行。通过libuv兼容层进行了封装。")]),_._v(" "),e("p",[_._v("实际上，.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有"),e("strong",[_._v("加载和执行")]),_._v("的过程。")]),_._v(" "),e("p",[_._v("优势主要是执行效率上的，劣势是C/C++模块编写门槛比JS高。")])]),_._v(" "),e("li",[e("p",[_._v("JSON文件的编译")]),_._v(" "),e("p",[_._v("最简单的，Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋值给模块对象的exports，以供外部调用。")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);